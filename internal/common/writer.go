package common

import "C"
import (
	"encoding/json"
	"fmt"
	"log"
	"os"
	"strings"
)

const author = "go-sfml"
const packageName = "sfml"

type TypeDef struct {
	Name  string
	CType string
}
type Writer struct {
	GithubRepo string
	Converter  *Converter
	Metadata   *Metadata

	RequiredTypeDefs  []TypeDef
	RequiredGoHelpers []string // Multiline strings that represent Go helper functions
	RequiredCHelpers  []string // Multiline strings that represent C helper functions

	acc strings.Builder
}

func NewWriter(githubRepo string, converter *Converter, metadataPath string) (*Writer, error) {
	metadata, err := readMetadata(metadataPath)
	if err != nil {
		return nil, fmt.Errorf("failed to read metadata from %s: %w", metadataPath, err)
	}

	// Go through all the struct overrides and check if there are any fields called "type".
	// If so, create a getter and setter for it.
	var typeHelpers []string
	for cName, structOverride := range converter.StructOverrides {
		for _, cField := range structOverride.CFields {

			if cField.Name == "type" {
				// Create a getter and setter for the "type" field
				typeHelpers = append(typeHelpers, fmt.Sprintf(`//
// static inline %s get_%s_type(const %s* a) {
//     return a->%s;
// }`,
					cField.Type, cName, cName, cField.Name))
				typeHelpers = append(typeHelpers, fmt.Sprintf(`//
// static inline void set_%s_type(%s* a, %s type) {
//     a->%s = type;
// }`,
					cName, cName, cField.Type, cField.Name))
			}
		}
	}

	for cName, unionOverride := range converter.UnionOverrides {
		cField := unionOverride.CTypeField
		if cField.Name == "type" {
			// Create a getter and setter for the "type" field
			typeHelpers = append(typeHelpers, fmt.Sprintf(`//
// static inline %s get_%s_type(const %s* a) {
//     return a->%s;
// }`,
				cField.Type, cName, cName, cField.Name))
			typeHelpers = append(typeHelpers, fmt.Sprintf(`//
// static inline void set_%s_type(%s* a, %s type) {
//     a->%s = type;
// }`,
				cName, cName, cField.Type, cField.Name))
		}
	}

	// Generate union field accessors for each union override like "get_sfSizeEvent_from_sfEvent_union"
	for cName, unionOverride := range converter.UnionOverrides {
		for _, mapper := range unionOverride.Mappers {
			if mapper.CTypeField.Name == "type" {
				continue // Skip if the type field is "type"
			}
			typeHelpers = append(typeHelpers, fmt.Sprintf(`// 
// static inline %s get_%s_from_%s_union(const %s* a) {
//     return a->%s;
// }`, mapper.CTypeField.Type, mapper.CTypeField.Type, cName, cName, mapper.CTypeField.Name))
		}
	}

	return &Writer{GithubRepo: githubRepo, Converter: converter, Metadata: metadata,
		RequiredTypeDefs: []TypeDef{
			{
				Name:  "uint",
				CType: "unsigned int",
			},
		},
		RequiredGoHelpers: []string{
			`
func boolToSfBool(b bool) C.sfBool {
	if b {
		return C.sfBool(1)
	}
	return C.sfBool(0)
}`,
			`
func sfBoolToBool(b C.sfBool) bool {
	if b == C.sfBool(1) {
		return true
	}
	return false
}`,
		},
		RequiredCHelpers: typeHelpers,
	}, nil
}

func readMetadata(path string) (*Metadata, error) {
	bytes, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}

	var metadata Metadata
	err = json.Unmarshal(bytes, &metadata)
	if err != nil {
		return nil, fmt.Errorf("failed to unmarshal metadata: %w", err)
	}

	return &metadata, nil
}

func (w *Writer) WriteString(s string) {
	w.acc.WriteString(s)
}

func (w *Writer) HeaderFunctions() {
	w.acc.WriteString(fmt.Sprintf("// Code generated by %s. DO NOT EDIT.\n\n", author))
	w.acc.WriteString(fmt.Sprintf("package %s\n\n", packageName))
	w.IncludeCLibs()
	w.CTypeDefs()
	w.CIncludeSFML()
	w.CLibsSFML()
	w.CHelpers()
	w.acc.WriteString("import \"C\"\n")
	w.acc.WriteString("import \"unsafe\"\n")
	w.acc.WriteString("\n")
}

func (w *Writer) HeaderTypes() {
	w.acc.WriteString(fmt.Sprintf("// Code generated by %s. DO NOT EDIT.\n\n", author))
	w.acc.WriteString(fmt.Sprintf("package %s\n\n", packageName))
	w.IncludeCLibs()
	w.CTypeDefs()
	w.CIncludeSFML()
	w.CLibsSFML()
	w.CHelpers()
	w.acc.WriteString("import \"C\"\n")
	w.acc.WriteString("import \"unsafe\"\n")
	w.acc.WriteString("\n")
	w.GoHelpers()
}

func (w *Writer) CTypeDefs() {
	for _, t := range w.RequiredTypeDefs {
		w.acc.WriteString(fmt.Sprintf("// typedef %s %s;\n", t.CType, t.Name))
	}
	w.acc.WriteString("//\n")
}

func (w *Writer) GoHelpers() {
	for _, helper := range w.RequiredGoHelpers {
		w.acc.WriteString(fmt.Sprintf("%s\n", helper))
	}
	w.acc.WriteString("\n")
}

func (w *Writer) CHelpers() {
	for _, helper := range w.RequiredCHelpers {
		w.acc.WriteString(fmt.Sprintf("%s\n", helper))
		w.acc.WriteString("//\n")
	}
	w.acc.WriteString("//\n")
}

func (w *Writer) ExternFunctions() {
	// mark every function as extern
	for _, function := range w.Converter.RawFunctions {
		signature := function.Signature
		w.acc.WriteString(fmt.Sprintf("// extern %s\n", signature))
	}
}

func (w *Writer) ForwardDeclareTypes() {
	for _, t := range w.Converter.RawTypes {
		if t.Type == "struct" {
			w.acc.WriteString(fmt.Sprintf("// struct %s;\n", t.Name))
		}
	}
}

func (w *Writer) CIncludeSFML() {
	for _, t := range w.Metadata.HeaderFiles {
		if t == "" {
			continue
		}
		w.acc.WriteString(fmt.Sprintf("// #include <%s>\n", t))
	}
}

func (w *Writer) CLibsSFML() {
	libs := []string{
		"csfml-graphics",
		"csfml-window",
		"csfml-system",
		"sfml-graphics",
		"sfml-window",
		"sfml-system",
		"X11",
		"stdc++",
		"m",
		"GL",
		"udev",
		"Xrandr",
		"freetype",
		"Xcursor",
	}

	libString := strings.Join(libs, " -l")
	w.acc.WriteString(fmt.Sprintf("// #cgo LDFLAGS: -l%s\n", libString))
}

func (w *Writer) IncludeCLibs() {
	libs := []string{
		"stdlib.h",
		"string.h",
	}

	for _, lib := range libs {
		w.acc.WriteString(fmt.Sprintf("// #include <%s>\n", lib))
	}
}

func (w *Writer) Struct(structDecl Struct) {
	w.acc.WriteString(fmt.Sprintf("type %s struct {\n", structDecl.Name))
	for _, field := range structDecl.Fields {
		w.acc.WriteString(fmt.Sprintf("\t%s %s\n", field.Name, field.Type))
	}
	w.acc.WriteString("}\n\n")
}

func (w *Writer) Interface(interfaceDecl Interface) {
	w.acc.WriteString(fmt.Sprintf("type %s interface {\n", interfaceDecl.Name))
	for _, method := range interfaceDecl.Methods {
		paramsStr := make([]string, len(method.Parameters))
		for i, param := range method.Parameters {
			if param.Name == "" {
				param.Name = fmt.Sprintf("arg%d", i)
			}
			paramsStr[i] = fmt.Sprintf("%s %s", param.Name, param.Type)
		}

		returnType := method.ReturnType
		if returnType != "" {
			returnType = " " + returnType
		}

		w.acc.WriteString(fmt.Sprintf("\t%s(%s)%s\n",
			method.MethodName,
			strings.Join(paramsStr, ", "),
			returnType,
		))
	}
	w.acc.WriteString("}\n\n")
}

func (w *Writer) Enum(enumDecl Enum) {
	w.acc.WriteString(fmt.Sprintf("type %s int32\n\n", enumDecl.Name))
	w.acc.WriteString(fmt.Sprintf("const (\n"))
	for _, enumerator := range enumDecl.Enumerators {
		w.acc.WriteString(fmt.Sprintf("\t%s %s = C.%s\n", enumerator.Name, enumDecl.Name, enumerator.Value))
	}
	w.acc.WriteString(")\n\n")
}

func (w *Writer) FunctionHeader(header FunctionHeader) {
	paramsStr := make([]string, len(header.Parameters))
	for i, param := range header.Parameters {
		paramType := param.Type
		if param.Name == "" {
			param.Name = fmt.Sprintf("arg%d", i)
		}
		paramsStr[i] = fmt.Sprintf("%s %s", param.Name, paramType)
	}

	returnType := header.ReturnType
	if returnType != "" {
		returnType = " " + returnType
	}

	w.acc.WriteString(fmt.Sprintf("func %s(%s)%s {\n",
		header.MethodName,
		strings.Join(paramsStr, ", "),
		returnType,
	))
}

func (w *Writer) ReceiverFunctionHeader(header ReceiverFunctionHeader) {
	paramsStr := make([]string, len(header.Parameters))
	for i, param := range header.Parameters {
		paramType := param.Type

		if param.Name == "" {
			param.Name = fmt.Sprintf("arg%d", i)
			log.Println("Warning: parameter name is empty, using fallback name:", param.Name)
		}
		paramsStr[i] = fmt.Sprintf("%s %s", param.Name, paramType)
	}

	returnType := header.ReturnType
	if returnType != "" {
		returnType = " " + returnType
	}

	w.acc.WriteString(fmt.Sprintf("func (%s %s) %s(%s)%s {\n",
		header.ReceiverName,
		header.ReceiverType,
		header.MethodName,
		strings.Join(paramsStr, ", "),
		returnType,
	))
}

func (w *Writer) FunctionBody(body FunctionBody) {
	for _, row := range body.Rows {
		w.acc.WriteString(fmt.Sprintf("\t%s\n", row))
	}
}

func (w *Writer) ReturnValue(returnValue string) {
	if returnValue != "" {
		w.acc.WriteString(fmt.Sprintf("\treturn %s\n", returnValue))
	} else {
		w.acc.WriteString("\treturn\n")
	}
	w.acc.WriteString("}\n\n")
}

func (w *Writer) VoidReturn() {
	w.acc.WriteString("}\n\n")
}

func (w *Writer) WriteToFile(filename string) error {
	file, err := os.Create(filename)
	if err != nil {
		return fmt.Errorf("failed to create file %s: %w", filename, err)
	}
	defer func(file *os.File) {
		closeErr := file.Close()
		if closeErr != nil {
			fmt.Printf("Warning: failed to close file %s: %v\n", filename, closeErr)
		}
	}(file)

	_, err = file.WriteString(w.acc.String())
	if err != nil {
		return fmt.Errorf("failed to write to file %s: %w", filename, err)
	}

	return nil
}
