package common

import (
	"fmt"
	"log"
	"os"
	"strings"
)

const author = "go-sfml"
const packageName = "sfml"

type Writer struct {
	GithubRepo string
	Converter  *Converter

	acc strings.Builder
}

func NewWriter(githubRepo string, converter *Converter) (*Writer, error) {
	return &Writer{GithubRepo: githubRepo, Converter: converter}, nil
}

func (w *Writer) WriteString(s string) {
	w.acc.WriteString(s)
}

func (w *Writer) HeaderFunctions() {
	w.acc.WriteString(fmt.Sprintf("// Code generated by %s. DO NOT EDIT.\n\n", author))
	w.acc.WriteString(fmt.Sprintf("package %s\n\n", packageName))
	w.acc.WriteString("import (\n")
	w.acc.WriteString("\t\"C\"\n")
	w.acc.WriteString("\t\"unsafe\"\n")
	w.acc.WriteString(")\n\n")
}

func (w *Writer) HeaderTypes() {
	w.acc.WriteString(fmt.Sprintf("// Code generated by %s. DO NOT EDIT.\n\n", author))
	w.acc.WriteString(fmt.Sprintf("package %s\n\n", packageName))
	w.acc.WriteString("import (\n")
	w.acc.WriteString("\t\"C\"\n")
	w.acc.WriteString("\t\"unsafe\"\n")
	w.acc.WriteString(")\n\n")
}

func (w *Writer) Struct(structDecl Struct) {
	w.acc.WriteString(fmt.Sprintf("type %s struct {\n", structDecl.Name))
	for _, field := range structDecl.Fields {
		w.acc.WriteString(fmt.Sprintf("\t%s %s\n", field.Name, field.Type))
	}
	w.acc.WriteString("}\n\n")
}

func (w *Writer) Enum(enumDecl Enum) {
	w.acc.WriteString(fmt.Sprintf("type %s int32\n\n", enumDecl.Name))
	w.acc.WriteString(fmt.Sprintf("const (\n"))
	for _, enumerator := range enumDecl.Enumerators {
		w.acc.WriteString(fmt.Sprintf("\t%s %s = C.%s\n", enumerator.Name, enumDecl.Name, enumerator.Name))
	}
	w.acc.WriteString(")\n\n")
}

func (w *Writer) FunctionHeader(header FunctionHeader) {
	paramsStr := make([]string, len(header.Parameters))
	for i, param := range header.Parameters {
		paramType := param.Type
		if param.Name == "" {
			param.Name = fmt.Sprintf("arg%d", i)
		}
		paramsStr[i] = fmt.Sprintf("%s %s", param.Name, paramType)
	}

	returnType := header.ReturnType
	if returnType != "" {
		returnType = " " + returnType
	}

	w.acc.WriteString(fmt.Sprintf("func %s(%s)%s {\n",
		header.MethodName,
		strings.Join(paramsStr, ", "),
		returnType,
	))
}

func (w *Writer) ReceiverFunctionHeader(header ReceiverFunctionHeader) {
	paramsStr := make([]string, len(header.Parameters))
	for i, param := range header.Parameters {
		paramType := param.Type

		if param.Name == "" {
			param.Name = fmt.Sprintf("arg%d", i)
			log.Println("Warning: parameter name is empty, using fallback name:", param.Name)
		}
		paramsStr[i] = fmt.Sprintf("%s %s", param.Name, paramType)
	}

	returnType := header.ReturnType
	if returnType != "" {
		returnType = " " + returnType
	}

	w.acc.WriteString(fmt.Sprintf("func (%s %s) %s(%s)%s {\n",
		header.ReceiverName,
		header.ReceiverType,
		header.MethodName,
		strings.Join(paramsStr, ", "),
		returnType,
	))
}

func (w *Writer) FunctionBody(body FunctionBody) {
	for _, row := range body.Rows {
		w.acc.WriteString(fmt.Sprintf("\t%s\n", row))
	}
}

func (w *Writer) ReturnValue(returnValue string) {
	if returnValue != "" {
		w.acc.WriteString(fmt.Sprintf("\treturn %s\n", returnValue))
	} else {
		w.acc.WriteString("\treturn\n")
	}
	w.acc.WriteString("}\n\n")
}

func (w *Writer) VoidReturn() {
	w.acc.WriteString("\treturn\n")
	w.acc.WriteString("}\n\n")
}

func (w *Writer) WriteToFile(filename string) error {
	file, err := os.Create(filename)
	if err != nil {
		return fmt.Errorf("failed to create file %s: %w", filename, err)
	}
	defer func(file *os.File) {
		closeErr := file.Close()
		if closeErr != nil {
			fmt.Printf("Warning: failed to close file %s: %v\n", filename, closeErr)
		}
	}(file)

	_, err = file.WriteString(w.acc.String())
	if err != nil {
		return fmt.Errorf("failed to write to file %s: %w", filename, err)
	}

	return nil
}
