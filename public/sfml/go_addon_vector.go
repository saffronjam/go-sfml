// Code generated by go-sfml. DO NOT EDIT.
package sfml

import (
	"fmt"
	"math"
)


// ------------------- Vector2f Methods -------------------

/*
Add returns a new vector representing the component-wise sum
of this vector and another.

Params:
  - other: the vector to add to this one.

Returns:
  - A new Vector2f representing the result of the addition.
*/
func (v *Vector2f) Add(other *Vector2f) *Vector2f {
	return &Vector2f{
		X: v.X + other.X,
		Y: v.Y + other.Y,
	}
}

/*
Subtract returns a new vector representing the component-wise difference
between this vector and another.

Params:
  - other: the vector to subtract from this one.

Returns:
  - A new Vector2f representing the result of the subtraction.
*/
func (v *Vector2f) Subtract(other *Vector2f) *Vector2f {
	return &Vector2f{
		X: v.X - other.X,
		Y: v.Y - other.Y,
	}
}

/*
Multiply returns a new vector with component-wise multiplication
of this vector and another.

Params:
  - other: the vector to multiply with.

Returns:
  - A new Vector2f with each component multiplied.
*/
func (v *Vector2f) Multiply(other *Vector2f) *Vector2f {
	return &Vector2f{
		X: v.X * other.X,
		Y: v.Y * other.Y,
	}
}

/*
MultiplyScalar multiplies each component of the vector by a scalar.

Params:
  - scalar: the scalar value to multiply by.

Returns:
  - A new Vector2f with each component scaled.
*/
func (v *Vector2f) MultiplyScalar(scalar float32) *Vector2f {
	return &Vector2f{
		X: v.X * scalar,
		Y: v.Y * scalar,
	}
}

/*
MultiplyScalars performs component-wise multiplication with individual scalar values.

Params:
  - x float32, y float32

Returns:
  - A new Vector2f with each component multiplied by its corresponding scalar.
*/
func (v *Vector2f) MultiplyScalars(x float32, y float32) *Vector2f {
	return &Vector2f{
		X: v.X * x,
		Y: v.Y * y,
	}
}

/*
Divide performs component-wise division of this vector by another.

Params:
  - other: the vector to divide by.

Returns:
  - A new Vector2f with each component divided.
*/
func (v *Vector2f) Divide(other *Vector2f) *Vector2f {
	return &Vector2f{
		X: v.X / other.X,
		Y: v.Y / other.Y,
	}
}

/*
DivideScalar divides each component by a scalar.

Params:
  - scalar: the scalar divisor.

Returns:
  - A new Vector2f with each component divided by scalar.
*/
func (v *Vector2f) DivideScalar(scalar float32) *Vector2f {
	return &Vector2f{
		X: v.X / scalar,
		Y: v.Y / scalar,
	}
}

/*
DivideScalars divides each component by its corresponding scalar.

Params:
  - x float32, y float32

Returns:
  - A new Vector2f with each component divided.
*/
func (v *Vector2f) DivideScalars(x float32, y float32) *Vector2f {
	return &Vector2f{
		X: v.X / x,
		Y: v.Y / y,
	}
}

/*
Equals returns true if all components of both vectors are equal.

Params:
  - other: the vector to compare with.

Returns:
  - Boolean indicating equality.
*/
func (v *Vector2f) Equals(other *Vector2f) bool {
	return v.X == other.X && v.Y == other.Y
}

/*
String returns a formatted string representation of the vector.
*/
func (v *Vector2f) String() string {
	return fmt.Sprintf("Vector2f(X: %f, Y: %f)", v.X, v.Y)
}


// --- Float-Specific Vector2f Methods ---

/*
LengthSquared returns the squared magnitude of the vector.

Returns:
  - Sum of squares of components.
*/
func (v *Vector2f) LengthSquared() float32 {
	return v.X*v.X + v.Y*v.Y
}

/*
Length returns the Euclidean length (magnitude) of the vector.

Returns:
  - Square root of LengthSquared.
*/
func (v *Vector2f) Length() float32 {
	return float32(math.Sqrt(float64(v.LengthSquared())))
}

/*
Normalize returns a unit vector pointing in the same direction.

Returns:
  - A normalized vector, or zero vector if original length is 0.
*/
func (v *Vector2f) Normalize() *Vector2f {
	if l := v.Length(); l != 0 {
		return v.DivideScalar(l)
	}
	return &Vector2f{}
}

/*
Dot returns the dot product with another vector.

Params:
  - other: the vector to dot with.

Returns:
  - Dot product (scalar).
*/
func (v *Vector2f) Dot(other *Vector2f) float32 {
	return v.X*other.X + v.Y*other.Y
}

/*
Distance returns the Euclidean distance between two vectors.

Params:
  - other: the vector to measure distance to.

Returns:
  - Distance as a float.
*/
func (v *Vector2f) Distance(other *Vector2f) float32 {
	return float32(math.Sqrt(float64(v.DistanceSquared(other))))
}

/*
DistanceSquared returns the squared distance between two vectors.

Params:
  - other: the vector to measure distance to.

Returns:
  - Squared distance (faster if exact distance isn't needed).
*/
func (v *Vector2f) DistanceSquared(other *Vector2f) float32 {
	return (v.X - other.X)*(v.X - other.X) + (v.Y - other.Y)*(v.Y - other.Y)
}

/*
Lerp performs linear interpolation toward another vector.

Params:
  - other: target vector.
  - t: interpolation factor in [0, 1].

Returns:
  - Interpolated vector between this and other.
*/
func (v *Vector2f) Lerp(other *Vector2f, t float32) *Vector2f {
	return &Vector2f{
		X: v.X + (other.X - v.X)*t,
		Y: v.Y + (other.Y - v.Y)*t,
	}
}

/*
Clamp limits each component to the corresponding range.

Params:
  - min: minimum vector values.
  - max: maximum vector values.

Returns:
  - Clamped vector.
*/
func (v *Vector2f) Clamp(min, max *Vector2f) *Vector2f {
	return &Vector2f{
		X: float32(math.Max(float64(min.X), math.Min(float64(max.X), float64(v.X)))),
		Y: float32(math.Max(float64(min.Y), math.Min(float64(max.Y), float64(v.Y)))),
	}
}

/*
Reflect reflects this vector around a surface normal.

Params:
  - normal: surface normal vector.

Returns:
  - Reflected vector.
*/
func (v *Vector2f) Reflect(normal *Vector2f) *Vector2f {
	dot := v.Dot(normal)
	return &Vector2f{
		X: v.X - 2*dot*normal.X,
		Y: v.Y - 2*dot*normal.Y,
	}
}

/*
Project projects this vector onto another.

Params:
  - other: vector to project onto.

Returns:
  - Projected vector.
*/
func (v *Vector2f) Project(other *Vector2f) *Vector2f {
	dot := v.Dot(other)
	lengthSquared := other.LengthSquared()
	if lengthSquared == 0 {
		return &Vector2f{}
	}
	scalar := dot / lengthSquared
	return &Vector2f{
		X: other.X * scalar,
		Y: other.Y * scalar,
	}
}

/*
SetLength returns a new vector in the same direction with a given length.

Params:
  - length: the desired length of the new vector.

Returns:
  - Rescaled vector, or zero vector if original length is zero.
*/
func (v *Vector2f) SetLength(length float32) *Vector2f {
	if v.Length() == 0 {
		return &Vector2f{}
	}
	return v.Normalize().MultiplyScalar(length)
}


/*
Rotate rotates a 2D vector by a given angle in degrees.

Params:
  - angle: angle to rotate in degrees.

Returns:
  - Rotated vector.
*/
func (v *Vector2f) Rotate(angle float32) *Vector2f {
	radians := angle * (math.Pi / 180.0)
	cos := float32(math.Cos(float64(radians)))
	sin := float32(math.Sin(float64(radians)))
	return &Vector2f{
		X: v.X*cos - v.Y*sin,
		Y: v.X*sin + v.Y*cos,
	}
}


// ------------------- Vector2i Methods -------------------

/*
Add returns a new vector representing the component-wise sum
of this vector and another.

Params:
  - other: the vector to add to this one.

Returns:
  - A new Vector2i representing the result of the addition.
*/
func (v *Vector2i) Add(other *Vector2i) *Vector2i {
	return &Vector2i{
		X: v.X + other.X,
		Y: v.Y + other.Y,
	}
}

/*
Subtract returns a new vector representing the component-wise difference
between this vector and another.

Params:
  - other: the vector to subtract from this one.

Returns:
  - A new Vector2i representing the result of the subtraction.
*/
func (v *Vector2i) Subtract(other *Vector2i) *Vector2i {
	return &Vector2i{
		X: v.X - other.X,
		Y: v.Y - other.Y,
	}
}

/*
Multiply returns a new vector with component-wise multiplication
of this vector and another.

Params:
  - other: the vector to multiply with.

Returns:
  - A new Vector2i with each component multiplied.
*/
func (v *Vector2i) Multiply(other *Vector2i) *Vector2i {
	return &Vector2i{
		X: v.X * other.X,
		Y: v.Y * other.Y,
	}
}

/*
MultiplyScalar multiplies each component of the vector by a scalar.

Params:
  - scalar: the scalar value to multiply by.

Returns:
  - A new Vector2i with each component scaled.
*/
func (v *Vector2i) MultiplyScalar(scalar int32) *Vector2i {
	return &Vector2i{
		X: v.X * scalar,
		Y: v.Y * scalar,
	}
}

/*
MultiplyScalars performs component-wise multiplication with individual scalar values.

Params:
  - x int32, y int32

Returns:
  - A new Vector2i with each component multiplied by its corresponding scalar.
*/
func (v *Vector2i) MultiplyScalars(x int32, y int32) *Vector2i {
	return &Vector2i{
		X: v.X * x,
		Y: v.Y * y,
	}
}

/*
Divide performs component-wise division of this vector by another.

Params:
  - other: the vector to divide by.

Returns:
  - A new Vector2i with each component divided.
*/
func (v *Vector2i) Divide(other *Vector2i) *Vector2i {
	return &Vector2i{
		X: v.X / other.X,
		Y: v.Y / other.Y,
	}
}

/*
DivideScalar divides each component by a scalar.

Params:
  - scalar: the scalar divisor.

Returns:
  - A new Vector2i with each component divided by scalar.
*/
func (v *Vector2i) DivideScalar(scalar int32) *Vector2i {
	return &Vector2i{
		X: v.X / scalar,
		Y: v.Y / scalar,
	}
}

/*
DivideScalars divides each component by its corresponding scalar.

Params:
  - x int32, y int32

Returns:
  - A new Vector2i with each component divided.
*/
func (v *Vector2i) DivideScalars(x int32, y int32) *Vector2i {
	return &Vector2i{
		X: v.X / x,
		Y: v.Y / y,
	}
}

/*
Equals returns true if all components of both vectors are equal.

Params:
  - other: the vector to compare with.

Returns:
  - Boolean indicating equality.
*/
func (v *Vector2i) Equals(other *Vector2i) bool {
	return v.X == other.X && v.Y == other.Y
}

/*
String returns a formatted string representation of the vector.
*/
func (v *Vector2i) String() string {
	return fmt.Sprintf("Vector2i(X: %d, Y: %d)", v.X, v.Y)
}



// ------------------- Vector2u Methods -------------------

/*
Add returns a new vector representing the component-wise sum
of this vector and another.

Params:
  - other: the vector to add to this one.

Returns:
  - A new Vector2u representing the result of the addition.
*/
func (v *Vector2u) Add(other *Vector2u) *Vector2u {
	return &Vector2u{
		X: v.X + other.X,
		Y: v.Y + other.Y,
	}
}

/*
Subtract returns a new vector representing the component-wise difference
between this vector and another.

Params:
  - other: the vector to subtract from this one.

Returns:
  - A new Vector2u representing the result of the subtraction.
*/
func (v *Vector2u) Subtract(other *Vector2u) *Vector2u {
	return &Vector2u{
		X: v.X - other.X,
		Y: v.Y - other.Y,
	}
}

/*
Multiply returns a new vector with component-wise multiplication
of this vector and another.

Params:
  - other: the vector to multiply with.

Returns:
  - A new Vector2u with each component multiplied.
*/
func (v *Vector2u) Multiply(other *Vector2u) *Vector2u {
	return &Vector2u{
		X: v.X * other.X,
		Y: v.Y * other.Y,
	}
}

/*
MultiplyScalar multiplies each component of the vector by a scalar.

Params:
  - scalar: the scalar value to multiply by.

Returns:
  - A new Vector2u with each component scaled.
*/
func (v *Vector2u) MultiplyScalar(scalar uint32) *Vector2u {
	return &Vector2u{
		X: v.X * scalar,
		Y: v.Y * scalar,
	}
}

/*
MultiplyScalars performs component-wise multiplication with individual scalar values.

Params:
  - x uint32, y uint32

Returns:
  - A new Vector2u with each component multiplied by its corresponding scalar.
*/
func (v *Vector2u) MultiplyScalars(x uint32, y uint32) *Vector2u {
	return &Vector2u{
		X: v.X * x,
		Y: v.Y * y,
	}
}

/*
Divide performs component-wise division of this vector by another.

Params:
  - other: the vector to divide by.

Returns:
  - A new Vector2u with each component divided.
*/
func (v *Vector2u) Divide(other *Vector2u) *Vector2u {
	return &Vector2u{
		X: v.X / other.X,
		Y: v.Y / other.Y,
	}
}

/*
DivideScalar divides each component by a scalar.

Params:
  - scalar: the scalar divisor.

Returns:
  - A new Vector2u with each component divided by scalar.
*/
func (v *Vector2u) DivideScalar(scalar uint32) *Vector2u {
	return &Vector2u{
		X: v.X / scalar,
		Y: v.Y / scalar,
	}
}

/*
DivideScalars divides each component by its corresponding scalar.

Params:
  - x uint32, y uint32

Returns:
  - A new Vector2u with each component divided.
*/
func (v *Vector2u) DivideScalars(x uint32, y uint32) *Vector2u {
	return &Vector2u{
		X: v.X / x,
		Y: v.Y / y,
	}
}

/*
Equals returns true if all components of both vectors are equal.

Params:
  - other: the vector to compare with.

Returns:
  - Boolean indicating equality.
*/
func (v *Vector2u) Equals(other *Vector2u) bool {
	return v.X == other.X && v.Y == other.Y
}

/*
String returns a formatted string representation of the vector.
*/
func (v *Vector2u) String() string {
	return fmt.Sprintf("Vector2u(X: %d, Y: %d)", v.X, v.Y)
}



// ------------------- Vector3f Methods -------------------

/*
Add returns a new vector representing the component-wise sum
of this vector and another.

Params:
  - other: the vector to add to this one.

Returns:
  - A new Vector3f representing the result of the addition.
*/
func (v *Vector3f) Add(other *Vector3f) *Vector3f {
	return &Vector3f{
		X: v.X + other.X,
		Y: v.Y + other.Y,
		Z: v.Z + other.Z,
	}
}

/*
Subtract returns a new vector representing the component-wise difference
between this vector and another.

Params:
  - other: the vector to subtract from this one.

Returns:
  - A new Vector3f representing the result of the subtraction.
*/
func (v *Vector3f) Subtract(other *Vector3f) *Vector3f {
	return &Vector3f{
		X: v.X - other.X,
		Y: v.Y - other.Y,
		Z: v.Z - other.Z,
	}
}

/*
Multiply returns a new vector with component-wise multiplication
of this vector and another.

Params:
  - other: the vector to multiply with.

Returns:
  - A new Vector3f with each component multiplied.
*/
func (v *Vector3f) Multiply(other *Vector3f) *Vector3f {
	return &Vector3f{
		X: v.X * other.X,
		Y: v.Y * other.Y,
		Z: v.Z * other.Z,
	}
}

/*
MultiplyScalar multiplies each component of the vector by a scalar.

Params:
  - scalar: the scalar value to multiply by.

Returns:
  - A new Vector3f with each component scaled.
*/
func (v *Vector3f) MultiplyScalar(scalar float32) *Vector3f {
	return &Vector3f{
		X: v.X * scalar,
		Y: v.Y * scalar,
		Z: v.Z * scalar,
	}
}

/*
MultiplyScalars performs component-wise multiplication with individual scalar values.

Params:
  - x float32, y float32, z float32

Returns:
  - A new Vector3f with each component multiplied by its corresponding scalar.
*/
func (v *Vector3f) MultiplyScalars(x float32, y float32, z float32) *Vector3f {
	return &Vector3f{
		X: v.X * x,
		Y: v.Y * y,
		Z: v.Z * z,
	}
}

/*
Divide performs component-wise division of this vector by another.

Params:
  - other: the vector to divide by.

Returns:
  - A new Vector3f with each component divided.
*/
func (v *Vector3f) Divide(other *Vector3f) *Vector3f {
	return &Vector3f{
		X: v.X / other.X,
		Y: v.Y / other.Y,
		Z: v.Z / other.Z,
	}
}

/*
DivideScalar divides each component by a scalar.

Params:
  - scalar: the scalar divisor.

Returns:
  - A new Vector3f with each component divided by scalar.
*/
func (v *Vector3f) DivideScalar(scalar float32) *Vector3f {
	return &Vector3f{
		X: v.X / scalar,
		Y: v.Y / scalar,
		Z: v.Z / scalar,
	}
}

/*
DivideScalars divides each component by its corresponding scalar.

Params:
  - x float32, y float32, z float32

Returns:
  - A new Vector3f with each component divided.
*/
func (v *Vector3f) DivideScalars(x float32, y float32, z float32) *Vector3f {
	return &Vector3f{
		X: v.X / x,
		Y: v.Y / y,
		Z: v.Z / z,
	}
}

/*
Equals returns true if all components of both vectors are equal.

Params:
  - other: the vector to compare with.

Returns:
  - Boolean indicating equality.
*/
func (v *Vector3f) Equals(other *Vector3f) bool {
	return v.X == other.X && v.Y == other.Y && v.Z == other.Z
}

/*
String returns a formatted string representation of the vector.
*/
func (v *Vector3f) String() string {
	return fmt.Sprintf("Vector3f(X: %f, Y: %f, Z: %f)", v.X, v.Y, v.Z)
}


// --- Float-Specific Vector3f Methods ---

/*
LengthSquared returns the squared magnitude of the vector.

Returns:
  - Sum of squares of components.
*/
func (v *Vector3f) LengthSquared() float32 {
	return v.X*v.X + v.Y*v.Y + v.Z*v.Z
}

/*
Length returns the Euclidean length (magnitude) of the vector.

Returns:
  - Square root of LengthSquared.
*/
func (v *Vector3f) Length() float32 {
	return float32(math.Sqrt(float64(v.LengthSquared())))
}

/*
Normalize returns a unit vector pointing in the same direction.

Returns:
  - A normalized vector, or zero vector if original length is 0.
*/
func (v *Vector3f) Normalize() *Vector3f {
	if l := v.Length(); l != 0 {
		return v.DivideScalar(l)
	}
	return &Vector3f{}
}

/*
Dot returns the dot product with another vector.

Params:
  - other: the vector to dot with.

Returns:
  - Dot product (scalar).
*/
func (v *Vector3f) Dot(other *Vector3f) float32 {
	return v.X*other.X + v.Y*other.Y + v.Z*other.Z
}

/*
Distance returns the Euclidean distance between two vectors.

Params:
  - other: the vector to measure distance to.

Returns:
  - Distance as a float.
*/
func (v *Vector3f) Distance(other *Vector3f) float32 {
	return float32(math.Sqrt(float64(v.DistanceSquared(other))))
}

/*
DistanceSquared returns the squared distance between two vectors.

Params:
  - other: the vector to measure distance to.

Returns:
  - Squared distance (faster if exact distance isn't needed).
*/
func (v *Vector3f) DistanceSquared(other *Vector3f) float32 {
	return (v.X - other.X)*(v.X - other.X) + (v.Y - other.Y)*(v.Y - other.Y) + (v.Z - other.Z)*(v.Z - other.Z)
}

/*
Lerp performs linear interpolation toward another vector.

Params:
  - other: target vector.
  - t: interpolation factor in [0, 1].

Returns:
  - Interpolated vector between this and other.
*/
func (v *Vector3f) Lerp(other *Vector3f, t float32) *Vector3f {
	return &Vector3f{
		X: v.X + (other.X - v.X)*t,
		Y: v.Y + (other.Y - v.Y)*t,
		Z: v.Z + (other.Z - v.Z)*t,
	}
}

/*
Clamp limits each component to the corresponding range.

Params:
  - min: minimum vector values.
  - max: maximum vector values.

Returns:
  - Clamped vector.
*/
func (v *Vector3f) Clamp(min, max *Vector3f) *Vector3f {
	return &Vector3f{
		X: float32(math.Max(float64(min.X), math.Min(float64(max.X), float64(v.X)))),
		Y: float32(math.Max(float64(min.Y), math.Min(float64(max.Y), float64(v.Y)))),
		Z: float32(math.Max(float64(min.Z), math.Min(float64(max.Z), float64(v.Z)))),
	}
}

/*
Reflect reflects this vector around a surface normal.

Params:
  - normal: surface normal vector.

Returns:
  - Reflected vector.
*/
func (v *Vector3f) Reflect(normal *Vector3f) *Vector3f {
	dot := v.Dot(normal)
	return &Vector3f{
		X: v.X - 2*dot*normal.X,
		Y: v.Y - 2*dot*normal.Y,
		Z: v.Z - 2*dot*normal.Z,
	}
}

/*
Project projects this vector onto another.

Params:
  - other: vector to project onto.

Returns:
  - Projected vector.
*/
func (v *Vector3f) Project(other *Vector3f) *Vector3f {
	dot := v.Dot(other)
	lengthSquared := other.LengthSquared()
	if lengthSquared == 0 {
		return &Vector3f{}
	}
	scalar := dot / lengthSquared
	return &Vector3f{
		X: other.X * scalar,
		Y: other.Y * scalar,
		Z: other.Z * scalar,
	}
}

/*
SetLength returns a new vector in the same direction with a given length.

Params:
  - length: the desired length of the new vector.

Returns:
  - Rescaled vector, or zero vector if original length is zero.
*/
func (v *Vector3f) SetLength(length float32) *Vector3f {
	if v.Length() == 0 {
		return &Vector3f{}
	}
	return v.Normalize().MultiplyScalar(length)
}



// ------------------- Vector3i Methods -------------------

/*
Add returns a new vector representing the component-wise sum
of this vector and another.

Params:
  - other: the vector to add to this one.

Returns:
  - A new Vector3i representing the result of the addition.
*/
func (v *Vector3i) Add(other *Vector3i) *Vector3i {
	return &Vector3i{
		X: v.X + other.X,
		Y: v.Y + other.Y,
		Z: v.Z + other.Z,
	}
}

/*
Subtract returns a new vector representing the component-wise difference
between this vector and another.

Params:
  - other: the vector to subtract from this one.

Returns:
  - A new Vector3i representing the result of the subtraction.
*/
func (v *Vector3i) Subtract(other *Vector3i) *Vector3i {
	return &Vector3i{
		X: v.X - other.X,
		Y: v.Y - other.Y,
		Z: v.Z - other.Z,
	}
}

/*
Multiply returns a new vector with component-wise multiplication
of this vector and another.

Params:
  - other: the vector to multiply with.

Returns:
  - A new Vector3i with each component multiplied.
*/
func (v *Vector3i) Multiply(other *Vector3i) *Vector3i {
	return &Vector3i{
		X: v.X * other.X,
		Y: v.Y * other.Y,
		Z: v.Z * other.Z,
	}
}

/*
MultiplyScalar multiplies each component of the vector by a scalar.

Params:
  - scalar: the scalar value to multiply by.

Returns:
  - A new Vector3i with each component scaled.
*/
func (v *Vector3i) MultiplyScalar(scalar int32) *Vector3i {
	return &Vector3i{
		X: v.X * scalar,
		Y: v.Y * scalar,
		Z: v.Z * scalar,
	}
}

/*
MultiplyScalars performs component-wise multiplication with individual scalar values.

Params:
  - x int32, y int32, z int32

Returns:
  - A new Vector3i with each component multiplied by its corresponding scalar.
*/
func (v *Vector3i) MultiplyScalars(x int32, y int32, z int32) *Vector3i {
	return &Vector3i{
		X: v.X * x,
		Y: v.Y * y,
		Z: v.Z * z,
	}
}

/*
Divide performs component-wise division of this vector by another.

Params:
  - other: the vector to divide by.

Returns:
  - A new Vector3i with each component divided.
*/
func (v *Vector3i) Divide(other *Vector3i) *Vector3i {
	return &Vector3i{
		X: v.X / other.X,
		Y: v.Y / other.Y,
		Z: v.Z / other.Z,
	}
}

/*
DivideScalar divides each component by a scalar.

Params:
  - scalar: the scalar divisor.

Returns:
  - A new Vector3i with each component divided by scalar.
*/
func (v *Vector3i) DivideScalar(scalar int32) *Vector3i {
	return &Vector3i{
		X: v.X / scalar,
		Y: v.Y / scalar,
		Z: v.Z / scalar,
	}
}

/*
DivideScalars divides each component by its corresponding scalar.

Params:
  - x int32, y int32, z int32

Returns:
  - A new Vector3i with each component divided.
*/
func (v *Vector3i) DivideScalars(x int32, y int32, z int32) *Vector3i {
	return &Vector3i{
		X: v.X / x,
		Y: v.Y / y,
		Z: v.Z / z,
	}
}

/*
Equals returns true if all components of both vectors are equal.

Params:
  - other: the vector to compare with.

Returns:
  - Boolean indicating equality.
*/
func (v *Vector3i) Equals(other *Vector3i) bool {
	return v.X == other.X && v.Y == other.Y && v.Z == other.Z
}

/*
String returns a formatted string representation of the vector.
*/
func (v *Vector3i) String() string {
	return fmt.Sprintf("Vector3i(X: %d, Y: %d, Z: %d)", v.X, v.Y, v.Z)
}



// ------------------- Vector4f Methods -------------------

/*
Add returns a new vector representing the component-wise sum
of this vector and another.

Params:
  - other: the vector to add to this one.

Returns:
  - A new Vector4f representing the result of the addition.
*/
func (v *Vector4f) Add(other *Vector4f) *Vector4f {
	return &Vector4f{
		X: v.X + other.X,
		Y: v.Y + other.Y,
		Z: v.Z + other.Z,
		W: v.W + other.W,
	}
}

/*
Subtract returns a new vector representing the component-wise difference
between this vector and another.

Params:
  - other: the vector to subtract from this one.

Returns:
  - A new Vector4f representing the result of the subtraction.
*/
func (v *Vector4f) Subtract(other *Vector4f) *Vector4f {
	return &Vector4f{
		X: v.X - other.X,
		Y: v.Y - other.Y,
		Z: v.Z - other.Z,
		W: v.W - other.W,
	}
}

/*
Multiply returns a new vector with component-wise multiplication
of this vector and another.

Params:
  - other: the vector to multiply with.

Returns:
  - A new Vector4f with each component multiplied.
*/
func (v *Vector4f) Multiply(other *Vector4f) *Vector4f {
	return &Vector4f{
		X: v.X * other.X,
		Y: v.Y * other.Y,
		Z: v.Z * other.Z,
		W: v.W * other.W,
	}
}

/*
MultiplyScalar multiplies each component of the vector by a scalar.

Params:
  - scalar: the scalar value to multiply by.

Returns:
  - A new Vector4f with each component scaled.
*/
func (v *Vector4f) MultiplyScalar(scalar float32) *Vector4f {
	return &Vector4f{
		X: v.X * scalar,
		Y: v.Y * scalar,
		Z: v.Z * scalar,
		W: v.W * scalar,
	}
}

/*
MultiplyScalars performs component-wise multiplication with individual scalar values.

Params:
  - x float32, y float32, z float32, w float32

Returns:
  - A new Vector4f with each component multiplied by its corresponding scalar.
*/
func (v *Vector4f) MultiplyScalars(x float32, y float32, z float32, w float32) *Vector4f {
	return &Vector4f{
		X: v.X * x,
		Y: v.Y * y,
		Z: v.Z * z,
		W: v.W * w,
	}
}

/*
Divide performs component-wise division of this vector by another.

Params:
  - other: the vector to divide by.

Returns:
  - A new Vector4f with each component divided.
*/
func (v *Vector4f) Divide(other *Vector4f) *Vector4f {
	return &Vector4f{
		X: v.X / other.X,
		Y: v.Y / other.Y,
		Z: v.Z / other.Z,
		W: v.W / other.W,
	}
}

/*
DivideScalar divides each component by a scalar.

Params:
  - scalar: the scalar divisor.

Returns:
  - A new Vector4f with each component divided by scalar.
*/
func (v *Vector4f) DivideScalar(scalar float32) *Vector4f {
	return &Vector4f{
		X: v.X / scalar,
		Y: v.Y / scalar,
		Z: v.Z / scalar,
		W: v.W / scalar,
	}
}

/*
DivideScalars divides each component by its corresponding scalar.

Params:
  - x float32, y float32, z float32, w float32

Returns:
  - A new Vector4f with each component divided.
*/
func (v *Vector4f) DivideScalars(x float32, y float32, z float32, w float32) *Vector4f {
	return &Vector4f{
		X: v.X / x,
		Y: v.Y / y,
		Z: v.Z / z,
		W: v.W / w,
	}
}

/*
Equals returns true if all components of both vectors are equal.

Params:
  - other: the vector to compare with.

Returns:
  - Boolean indicating equality.
*/
func (v *Vector4f) Equals(other *Vector4f) bool {
	return v.X == other.X && v.Y == other.Y && v.Z == other.Z && v.W == other.W
}

/*
String returns a formatted string representation of the vector.
*/
func (v *Vector4f) String() string {
	return fmt.Sprintf("Vector4f(X: %f, Y: %f, Z: %f, W: %f)", v.X, v.Y, v.Z, v.W)
}


// --- Float-Specific Vector4f Methods ---

/*
LengthSquared returns the squared magnitude of the vector.

Returns:
  - Sum of squares of components.
*/
func (v *Vector4f) LengthSquared() float32 {
	return v.X*v.X + v.Y*v.Y + v.Z*v.Z + v.W*v.W
}

/*
Length returns the Euclidean length (magnitude) of the vector.

Returns:
  - Square root of LengthSquared.
*/
func (v *Vector4f) Length() float32 {
	return float32(math.Sqrt(float64(v.LengthSquared())))
}

/*
Normalize returns a unit vector pointing in the same direction.

Returns:
  - A normalized vector, or zero vector if original length is 0.
*/
func (v *Vector4f) Normalize() *Vector4f {
	if l := v.Length(); l != 0 {
		return v.DivideScalar(l)
	}
	return &Vector4f{}
}

/*
Dot returns the dot product with another vector.

Params:
  - other: the vector to dot with.

Returns:
  - Dot product (scalar).
*/
func (v *Vector4f) Dot(other *Vector4f) float32 {
	return v.X*other.X + v.Y*other.Y + v.Z*other.Z + v.W*other.W
}

/*
Distance returns the Euclidean distance between two vectors.

Params:
  - other: the vector to measure distance to.

Returns:
  - Distance as a float.
*/
func (v *Vector4f) Distance(other *Vector4f) float32 {
	return float32(math.Sqrt(float64(v.DistanceSquared(other))))
}

/*
DistanceSquared returns the squared distance between two vectors.

Params:
  - other: the vector to measure distance to.

Returns:
  - Squared distance (faster if exact distance isn't needed).
*/
func (v *Vector4f) DistanceSquared(other *Vector4f) float32 {
	return (v.X - other.X)*(v.X - other.X) + (v.Y - other.Y)*(v.Y - other.Y) + (v.Z - other.Z)*(v.Z - other.Z) + (v.W - other.W)*(v.W - other.W)
}

/*
Lerp performs linear interpolation toward another vector.

Params:
  - other: target vector.
  - t: interpolation factor in [0, 1].

Returns:
  - Interpolated vector between this and other.
*/
func (v *Vector4f) Lerp(other *Vector4f, t float32) *Vector4f {
	return &Vector4f{
		X: v.X + (other.X - v.X)*t,
		Y: v.Y + (other.Y - v.Y)*t,
		Z: v.Z + (other.Z - v.Z)*t,
		W: v.W + (other.W - v.W)*t,
	}
}

/*
Clamp limits each component to the corresponding range.

Params:
  - min: minimum vector values.
  - max: maximum vector values.

Returns:
  - Clamped vector.
*/
func (v *Vector4f) Clamp(min, max *Vector4f) *Vector4f {
	return &Vector4f{
		X: float32(math.Max(float64(min.X), math.Min(float64(max.X), float64(v.X)))),
		Y: float32(math.Max(float64(min.Y), math.Min(float64(max.Y), float64(v.Y)))),
		Z: float32(math.Max(float64(min.Z), math.Min(float64(max.Z), float64(v.Z)))),
		W: float32(math.Max(float64(min.W), math.Min(float64(max.W), float64(v.W)))),
	}
}

/*
Reflect reflects this vector around a surface normal.

Params:
  - normal: surface normal vector.

Returns:
  - Reflected vector.
*/
func (v *Vector4f) Reflect(normal *Vector4f) *Vector4f {
	dot := v.Dot(normal)
	return &Vector4f{
		X: v.X - 2*dot*normal.X,
		Y: v.Y - 2*dot*normal.Y,
		Z: v.Z - 2*dot*normal.Z,
		W: v.W - 2*dot*normal.W,
	}
}

/*
Project projects this vector onto another.

Params:
  - other: vector to project onto.

Returns:
  - Projected vector.
*/
func (v *Vector4f) Project(other *Vector4f) *Vector4f {
	dot := v.Dot(other)
	lengthSquared := other.LengthSquared()
	if lengthSquared == 0 {
		return &Vector4f{}
	}
	scalar := dot / lengthSquared
	return &Vector4f{
		X: other.X * scalar,
		Y: other.Y * scalar,
		Z: other.Z * scalar,
		W: other.W * scalar,
	}
}

/*
SetLength returns a new vector in the same direction with a given length.

Params:
  - length: the desired length of the new vector.

Returns:
  - Rescaled vector, or zero vector if original length is zero.
*/
func (v *Vector4f) SetLength(length float32) *Vector4f {
	if v.Length() == 0 {
		return &Vector4f{}
	}
	return v.Normalize().MultiplyScalar(length)
}



// ------------------- Vector4i Methods -------------------

/*
Add returns a new vector representing the component-wise sum
of this vector and another.

Params:
  - other: the vector to add to this one.

Returns:
  - A new Vector4i representing the result of the addition.
*/
func (v *Vector4i) Add(other *Vector4i) *Vector4i {
	return &Vector4i{
		X: v.X + other.X,
		Y: v.Y + other.Y,
		Z: v.Z + other.Z,
		W: v.W + other.W,
	}
}

/*
Subtract returns a new vector representing the component-wise difference
between this vector and another.

Params:
  - other: the vector to subtract from this one.

Returns:
  - A new Vector4i representing the result of the subtraction.
*/
func (v *Vector4i) Subtract(other *Vector4i) *Vector4i {
	return &Vector4i{
		X: v.X - other.X,
		Y: v.Y - other.Y,
		Z: v.Z - other.Z,
		W: v.W - other.W,
	}
}

/*
Multiply returns a new vector with component-wise multiplication
of this vector and another.

Params:
  - other: the vector to multiply with.

Returns:
  - A new Vector4i with each component multiplied.
*/
func (v *Vector4i) Multiply(other *Vector4i) *Vector4i {
	return &Vector4i{
		X: v.X * other.X,
		Y: v.Y * other.Y,
		Z: v.Z * other.Z,
		W: v.W * other.W,
	}
}

/*
MultiplyScalar multiplies each component of the vector by a scalar.

Params:
  - scalar: the scalar value to multiply by.

Returns:
  - A new Vector4i with each component scaled.
*/
func (v *Vector4i) MultiplyScalar(scalar int32) *Vector4i {
	return &Vector4i{
		X: v.X * scalar,
		Y: v.Y * scalar,
		Z: v.Z * scalar,
		W: v.W * scalar,
	}
}

/*
MultiplyScalars performs component-wise multiplication with individual scalar values.

Params:
  - x int32, y int32, z int32, w int32

Returns:
  - A new Vector4i with each component multiplied by its corresponding scalar.
*/
func (v *Vector4i) MultiplyScalars(x int32, y int32, z int32, w int32) *Vector4i {
	return &Vector4i{
		X: v.X * x,
		Y: v.Y * y,
		Z: v.Z * z,
		W: v.W * w,
	}
}

/*
Divide performs component-wise division of this vector by another.

Params:
  - other: the vector to divide by.

Returns:
  - A new Vector4i with each component divided.
*/
func (v *Vector4i) Divide(other *Vector4i) *Vector4i {
	return &Vector4i{
		X: v.X / other.X,
		Y: v.Y / other.Y,
		Z: v.Z / other.Z,
		W: v.W / other.W,
	}
}

/*
DivideScalar divides each component by a scalar.

Params:
  - scalar: the scalar divisor.

Returns:
  - A new Vector4i with each component divided by scalar.
*/
func (v *Vector4i) DivideScalar(scalar int32) *Vector4i {
	return &Vector4i{
		X: v.X / scalar,
		Y: v.Y / scalar,
		Z: v.Z / scalar,
		W: v.W / scalar,
	}
}

/*
DivideScalars divides each component by its corresponding scalar.

Params:
  - x int32, y int32, z int32, w int32

Returns:
  - A new Vector4i with each component divided.
*/
func (v *Vector4i) DivideScalars(x int32, y int32, z int32, w int32) *Vector4i {
	return &Vector4i{
		X: v.X / x,
		Y: v.Y / y,
		Z: v.Z / z,
		W: v.W / w,
	}
}

/*
Equals returns true if all components of both vectors are equal.

Params:
  - other: the vector to compare with.

Returns:
  - Boolean indicating equality.
*/
func (v *Vector4i) Equals(other *Vector4i) bool {
	return v.X == other.X && v.Y == other.Y && v.Z == other.Z && v.W == other.W
}

/*
String returns a formatted string representation of the vector.
*/
func (v *Vector4i) String() string {
	return fmt.Sprintf("Vector4i(X: %d, Y: %d, Z: %d, W: %d)", v.X, v.Y, v.Z, v.W)
}


